package i5.las2peer.services.codeGenerationService.generators;

import java.awt.image.BufferedImage;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import javax.imageio.ImageIO;

import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.LsRemoteCommand;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.revwalk.RevTree;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.transport.CredentialsProvider;
import org.eclipse.jgit.transport.RefSpec;
import org.eclipse.jgit.transport.RemoteConfig;
import org.eclipse.jgit.transport.URIish;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.eclipse.jgit.treewalk.TreeWalk;
import org.json.simple.JSONObject;

import com.sun.corba.se.pept.transport.Connection;

import i5.las2peer.api.Service;
import i5.las2peer.logging.L2pLogger;
import i5.las2peer.services.codeGenerationService.adapters.GitLabAdapter;
import i5.las2peer.services.codeGenerationService.exception.GitHostException;
import i5.las2peer.services.codeGenerationService.models.traceModel.FileTraceModel;
import i5.las2peer.services.codeGenerationService.models.traceModel.TraceModel;

/**
 * 
 * Abstract class providing means to create local repositories, add files to them and push them to a
 * remote GitHub repository. Does not provide means to commit files (please do manually).
 *
 */
public abstract class Generator {


  private static final L2pLogger logger =
      L2pLogger.getInstance(ApplicationGenerator.class.getName());

  /**
   * 
   * Generates a new (local) repository to add files to. Also creates a (remote) GitHub repository
   * with the same name and adds it to the (local) repository's configuration to be later used as
   * its remote entry to push to.
   * 
   * @param name the name of the repository to be created
   * @param gitHubOrganization the organization that is used in the CAE
   * @param gitHubUser the CAE user
   * @param gitHubPassword the password of the CAE user
   * 
   * @return a {@link org.eclipse.jgit.lib.Repository}
   * 
   * @throws GitHostException if anything goes wrong during this creation process
   * 
   */
  @SuppressWarnings("unchecked")
  public static Repository generateNewRepository(String name, String gitHubOrganization,
      String gitHubUser, String gitHubPassword, String usedGitHost) throws GitHostException {

    Git git = null;
    File localPath = null;

    // prepare a new folder for the new repository
    try {
      localPath = File.createTempFile(name, "");
      localPath.delete();
    } catch (IOException e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }

    // add a remote configuration (origin) to the newly created repository
    try {
      git = Git.init().setDirectory(localPath).call();
      StoredConfig config = git.getRepository().getConfig();
      
      RemoteConfig remoteConfig = null;
      
      switch (usedGitHost) {
	case "GitHub":
		remoteConfig = new RemoteConfig(config, "GitHub");
		remoteConfig.addURI(new URIish("https://github.com/" + gitHubOrganization + "/" + name));
		break;
	case "GitLab":
		remoteConfig = new RemoteConfig(config, "GitLab");
		remoteConfig.addURI(new URIish("http://ginkgo.informatik.rwth-aachen.de:4080/" + gitHubOrganization + "/" + name + ".git"));
		break;
	}
      
      remoteConfig.update(config);
      config.save();
    } catch (Exception e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }

    // now create empty GitHub repository with an HTTP request, using the GitHub API directly
    // because jGit does not support direct GitHub repository creation..
    try {
      if(Objects.equals(usedGitHost, "GitLab")) {
    	  GitLabAdapter.createRepo(gitHubOrganization,name, 
    			  "This repository was generated by the CAE, it features the generated source code from " + name);
      } 
      
      if(Objects.equals(usedGitHost, "GitHub")) {
    	  
    	  JSONObject jsonObject = new JSONObject();
          jsonObject.put("name", name);
          jsonObject.put("description",
              "This repository was generated by the CAE, it features the generated source code from "
                  + name);
          String body = JSONObject.toJSONString(jsonObject);

          String authString = gitHubUser + ":" + gitHubPassword;
          byte[] authEncBytes = Base64.getEncoder().encode(authString.getBytes());
          String authStringEnc = new String(authEncBytes);

          
          URL url;
    	  url = new URL("https://api.github.com/orgs/" + gitHubOrganization + "/repos");
    	  
		  HttpURLConnection connection = (HttpURLConnection) url.openConnection();
		  connection.setRequestMethod("POST");
		  connection.setDoInput(true);
		  connection.setDoOutput(true);
		  connection.setUseCaches(false);
		  connection.setRequestProperty("Accept", "application/vnd.github.v3+json");
		  connection.setRequestProperty("Content-Type", "application/vnd.github.v3+json");
		  connection.setRequestProperty("Content-Length", String.valueOf(body.length()));
		  connection.setRequestProperty("Authorization", "Basic " + authStringEnc);
		
		  OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
		  writer.write(body);
		  writer.flush();
		  writer.close();
		
		  // forward (in case of) error
		  if (connection.getResponseCode() != 201) {
		    String message = "Error creating repository at: ";
		    BufferedReader reader =
		        new BufferedReader(new InputStreamReader(connection.getErrorStream()));
		    for (String line; (line = reader.readLine()) != null;) {
		      message += line;
		    }
		    reader.close();
		    throw new GitHostException(message);
		  }
      }
      
    } catch (MalformedURLException e) {
    	logger.printStackTrace(e);
      	throw new GitHostException(e.getMessage());
    } catch (IOException e) {
    	logger.printStackTrace(e);
    	throw new GitHostException(e.getMessage());
    }
    return git.getRepository();
  }


  /**
   * 
   * Clones the template repository from GitHub to the local machine and returns a
   * {@link org.eclipse.jgit.treewalk.TreeWalk} that can be used to retrieve the repository's
   * content. Repository is used "read-only" here.
   * 
   * @param templateRepositoryName the name of the template repository
   * @param gitHubOrganization the organization that is used in the CAE
   * 
   * @return a {@link org.eclipse.jgit.treewalk.TreeWalk}
   * 
   * @throws GitHostException if anything goes wrong during retrieving the repository's content
   * 
   */
  public static TreeWalk getTemplateRepositoryContent(String templateRepositoryName,
      String gitHubOrganization, String usedGitHost) throws GitHostException {
    Repository templateRepository = getRemoteRepository(templateRepositoryName, gitHubOrganization, usedGitHost);
    
    if (templateRepository == null) {
    	throw new GitHostException("Template repository is null!");
    }
    
    // get the content of the repository
    RevWalk revWalk = null;
    TreeWalk treeWalk = null;
    
    try {
      ObjectId lastCommitId = templateRepository.resolve(Constants.HEAD);
      
      if (lastCommitId == null) {
		throw new GitHostException("lastCommit is null, template repo is probably empty");
      }
      
      treeWalk = new TreeWalk(templateRepository);
      revWalk = new RevWalk(templateRepository);
      RevTree tree = revWalk.parseCommit(lastCommitId).getTree();
      treeWalk.addTree(tree);
      treeWalk.setRecursive(true);
    } catch (Exception e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    } finally {
      templateRepository.close();
      revWalk.close();
    }
    return treeWalk;
  }



  /**
   * 
   * Clones a repository from GitHub to the local machine and returns a
   * {@link org.eclipse.jgit.treewalk.TreeWalk} that can be used to retrieve the repository's
   * content. Repository is used "read-only" here.
   * 
   * @param repositoryName the name of the template repository
   * @param gitHubOrganization the organization that is used in the CAE
   * 
   * @return a {@link org.eclipse.jgit.treewalk.TreeWalk}
   * 
   * @throws GitHostException if anything goes wrong during retrieving the repository's content
   * 
   */
  public static TreeWalk getRepositoryContent(String repositoryName, String gitHubOrganization, String usedGitHost)
      throws GitHostException {
    Repository repository = getRemoteRepository(repositoryName, gitHubOrganization, usedGitHost);
    // get the content of the repository
    RevWalk revWalk = null;
    TreeWalk treeWalk = null;
    String resolveString = Constants.HEAD;

    if (repositoryName.startsWith("frontendComponent")) {
      resolveString = "refs/remotes/origin/gh-pages";
    }

    try {
      ObjectId lastCommitId = repository.resolve(resolveString);
      treeWalk = new TreeWalk(repository);
      revWalk = new RevWalk(repository);
      RevTree tree = revWalk.parseCommit(lastCommitId).getTree();
      treeWalk.addTree(tree);
      treeWalk.setRecursive(true);
    } catch (Exception e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    } finally {
      repository.close();
      revWalk.close();
    }
    return treeWalk;
  }



  /**
   * 
   * Clones a repository from GitHub to the local machine and returns it.
   * 
   * @param repositoryName the name of the repository
   * @param gitHubOrganization the organization that is used in the CAE
   * 
   * @return a {@link org.eclipse.jgit.lib.Repository}
   * 
   * @throws GitHostException if anything goes wrong during retrieving the repository's content
   * 
   */
  private static Repository getRemoteRepository(String repositoryName, String gitHubOrganization, String usedGitHost)
      throws GitHostException {
	  String repositoryAddress;
	switch (usedGitHost) {
	case "GitHub":
		repositoryAddress = "https://github.com/" + gitHubOrganization + "/" + repositoryName + ".git";
		break;
	case "GitLab":
		// example: http://ginkgo.informatik.rwth-aachen.de:4080/ugnm1617g1CAE/test.git
		repositoryAddress = "http://ginkgo.informatik.rwth-aachen.de:4080/" + gitHubOrganization + "/" + repositoryName + ".git";
		break;
	default:
		repositoryAddress = "https://github.com/" + gitHubOrganization + "/" + repositoryName + ".git";
		break;
	}
    Repository repository = null;
    // prepare a new folder for the template repository (to be cloned)
    File localPath = null;
    try {
      localPath = File.createTempFile(repositoryName, "");
    } catch (IOException e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }
    localPath.delete();

    // then clone
    try {
    	//TODO: Remove password
      CredentialsProvider prov = new UsernamePasswordCredentialsProvider("ugnm1617", "M6rMThqp8W7CFGpB");
      
      repository = Git
    		  .cloneRepository().setCredentialsProvider(prov)
    		  .setURI(repositoryAddress).setDirectory(localPath)
    		  .call().getRepository();
      
    } catch (Exception e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }

    return repository;
  }



  /**
   * 
   * Adds a text (source code-)file to the repository. Beware of side effects, due to adding all
   * files in main folder to staged area currently.
   * 
   * @param repository the repository the file should be added to
   * @param relativePath the relative path the file should reside at; without first separator
   * @param fileName the file name
   * @param content the content the file should have
   * 
   * @return the {@link org.eclipse.jgit.lib.Repository}, now containing one more file
   * 
   * @throws GitHostException if anything goes wrong during the creation of the file
   * 
   */
  public static Repository createTextFileInRepository(Repository repository, String relativePath,
      String fileName, String content) throws GitHostException {

    File dirs = new File(repository.getDirectory().getParent() + "/" + relativePath);
    dirs.mkdirs();

    try {
      OutputStream file = new FileOutputStream(
          repository.getDirectory().getParent() + "/" + relativePath + fileName);
      OutputStream buffer = new BufferedOutputStream(file);
      PrintStream printStream = new PrintStream(buffer);
      printStream.print(content);
      printStream.close();
    } catch (IOException e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }

    // stage file
    try {
      Git.wrap(repository).add().addFilepattern(".").call();
    } catch (Exception e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }
    return repository;

  }


  /**
   * 
   * Adds a binary file to the repository. Beware of side effects, due to adding all files in main
   * folder to staged area currently.
   * 
   * @param repository the repository the file should be added to
   * @param relativePath the relative path the file should reside at; without first separator
   * @param fileName the file name
   * @param content the content the file should have
   * 
   * @return the {@link org.eclipse.jgit.lib.Repository}, now containing one more file
   * 
   * @throws GitHostException if anything goes wrong during the creation of the file
   * 
   */
  public static Repository createBinaryFileInRepository(Repository repository, String relativePath,
      String fileName, Object content) throws GitHostException {

    File dirs = new File(repository.getDirectory().getParent() + "/" + relativePath);
    dirs.mkdirs();

    try {
      OutputStream file = new FileOutputStream(
          repository.getDirectory().getParent() + "/" + relativePath + fileName);
      OutputStream buffer = new BufferedOutputStream(file);
      ObjectOutput output = new ObjectOutputStream(buffer);
      output.writeObject(content);
      output.close();
    } catch (IOException e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }

    // stage file
    try {
      Git.wrap(repository).add().addFilepattern(".").call();
    } catch (Exception e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }
    return repository;

  }


  /**
   * 
   * Adds an image file to the repository. Beware of side effects, due to adding all files in main
   * folder to staged area currently.
   * 
   * @param repository the repository the file should be added to
   * @param relativePath the relative path the file should reside at; without first separator
   * @param fileName the file name
   * @param content the content the image should have
   * 
   * @return the {@link org.eclipse.jgit.lib.Repository}, now containing one more file
   * 
   * @throws GitHostException if anything goes wrong during the creation of the file
   * 
   */
  public static Repository createImageFileInRepository(Repository repository, String relativePath,
      String fileName, BufferedImage content) throws GitHostException {

    File dirs = new File(repository.getDirectory().getParent() + "/" + relativePath);
    dirs.mkdirs();

    try {
      File file = new File(repository.getDirectory().getParent() + "/" + relativePath + fileName);
      ImageIO.write(content, fileName.substring(fileName.lastIndexOf(".") + 1), file);
    } catch (IOException e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }

    // stage file
    try {
      Git.wrap(repository).add().addFilepattern(".").call();
    } catch (Exception e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }
    return repository;

  }


  /**
   * 
   * Pushes a local repository (from and) to the "master" branch on GitHub. This method only works
   * with repositories previously created by {@link #generateNewRepository}.
   * 
   * @param repository the {@link org.eclipse.jgit.lib.Repository} to be pushed to GitHub
   * @param gitHubUser the CAE user
   * @param gitHubPassword the password of the CAE user
   * 
   * @return the {@link org.eclipse.jgit.lib.Repository} that was pushed
   * 
   * @throws GitHostException if anything goes wrong during the push command
   * 
   */
  public static Repository pushToRemoteRepository(Repository repository, String gitHubUser,
      String gitHubPassword, String usedGitHost) throws GitHostException {
    return pushToRemoteRepository(repository, gitHubUser, gitHubPassword, "master", "master", usedGitHost);
  }


  /**
   * 
   * Pushes a local repository to GitHub. This method only works with repositories previously
   * created by {@link #generateNewRepository}.
   * 
   * @param repository the {@link org.eclipse.jgit.lib.Repository} to be pushed to GitHub
   * @param gitHubUser the CAE user
   * @param gitHubPassword the password of the CAE user
   * @param localBranchName the name of the branch that should be pushed from
   * @param remoteBranchName the name of the branch that should be pushed to
   * 
   * @return the {@link org.eclipse.jgit.lib.Repository} that was pushed
   * 
   * @throws GitHostException if anything goes wrong during the push command
   * 
   */
  public static Repository pushToRemoteRepository(Repository repository, String gitHubUser,
      String gitHubPassword, String localBranchName, String remoteBranchName, String usedGitHost)
      throws GitHostException {
    CredentialsProvider credentialsProvider =
        new UsernamePasswordCredentialsProvider(gitHubUser, gitHubPassword);
    try {
      // the "setRemote" parameter name is defined in the generateNewRepository method
      RefSpec spec =
          new RefSpec("refs/heads/" + localBranchName + ":refs/heads/" + remoteBranchName);
      Git.wrap(repository).push().setRemote(usedGitHost).setCredentialsProvider(credentialsProvider)
          .setRefSpecs(spec).call();
    } catch (Exception e) {
      logger.printStackTrace(e);
      throw new GitHostException(e.getMessage());
    }
    return repository;
  }


  /**
   * 
   * Deletes a repository on GitHub, given by its name.
   * 
   * @param name the name of the repository
   * @param gitHubOrganization the name of the repositories organization
   * @param gitHubUser the name of the GitHub user
   * @param gitHubPassword the password of the GitHub user
   * 
   * @throws GitHostException if deletion was not successful
   * 
   */
  public static void deleteRemoteRepository(String name, String gitHubOrganization,
      String gitHubUser, String gitHubPassword, String usedGitHost) throws GitHostException {
    
	  if(Objects.equals(usedGitHost,"GitLab")){
		  //See new adapter class
		  GitLabAdapter.deleteRepo(name, gitHubOrganization);
	  }
	  else if(Objects.equals(usedGitHost,"GitHub") || Objects.equals(usedGitHost, "")) {
		  try {
		      String authString = gitHubUser + ":" + gitHubPassword;
		      byte[] authEncBytes = Base64.getEncoder().encode(authString.getBytes());
		      String authStringEnc = new String(authEncBytes);
		      URL url = new URL("https://api.github.com/repos/" + gitHubOrganization + "/" + name);
		      HttpURLConnection connection = (HttpURLConnection) url.openConnection();
		      connection.setRequestMethod("DELETE");
		      connection.setUseCaches(false);
		      connection.setRequestProperty("Authorization", "Basic " + authStringEnc);
		
		      // forward (in case of) error
		      if (connection.getResponseCode() != 204) {
		        String message = "Error deleting repository: ";
		        BufferedReader reader =
		            new BufferedReader(new InputStreamReader(connection.getErrorStream()));
		        for (String line; (line = reader.readLine()) != null;) {
		          message += line;
		        }
		        reader.close();
		        throw new GitHostException(message);
		      }
	
	    } catch (Exception e) {
	      logger.printStackTrace(e);
	      throw new GitHostException(e.getMessage());
	    }
	  } else {
		  throw new GitHostException("No valid gitHost selected");
	  }
  }

  /**
   * Checks whether a remote repository of the given name in the given github organization exists.
   * Uses the ls remote git command to determine if the repository exists.
   * 
   * @param name The name of the repository
   * @param gitHubOrganization The git hub organization
   * @param gitHubUser The git hub user
   * @param gitHubPassword The git hub password
   * @return True, if the repository exists, otherwise false
   */

  public static boolean existsRemoteRepository(String name, String gitHubOrganization,
      String gitHubUser, String gitHubPassword, String usedGitHost) {
    CredentialsProvider credentialsProvider =
        new UsernamePasswordCredentialsProvider(gitHubUser, gitHubPassword);
    LsRemoteCommand lsCmd = new LsRemoteCommand(null);
    
    String url;
    
    switch (usedGitHost) {
	case "GitHub":
		url = "https://github.com/" + gitHubOrganization + "/" + name + ".git";
		break;
	case "GitLab":
		url = "http://ginkgo.informatik.rwth-aachen.de:4080/" + gitHubOrganization + "/" + name + ".git";
		break;
	default:
		url = "https://github.com/" + gitHubOrganization + "/" + name + ".git";
		break;
	}
    
    lsCmd.setRemote(url);
    lsCmd.setHeads(true);
    lsCmd.setCredentialsProvider(credentialsProvider);
    boolean exists = true;
    try {
      lsCmd.call();
    } catch (Exception e) {
      // ignore the exception, as this is the way we determine if a remote repository exists
      exists = false;
    }
    return exists;
  }

  /**
   * Creates the traced files contained in the given global trace model in the given repository
   * 
   * @param traceModel The global trace model containing the traced files that should be created in
   *        the repository
   * @param repository The repository in which the files should be created
   * 
   * @return The {@link org.eclipse.jgit.lib.Repository}, now containing the traced files of the
   *         trace model
   * @throws GitHostException if anything goes wrong during the creation of the traced files
   */

  protected static Repository createTracedFilesInRepository(TraceModel traceModel,
      Repository repository) throws GitHostException {
    Map<String, FileTraceModel> fileTraceMap = traceModel.getFilenameToFileTraceModelMap();

    for (String fullPath : fileTraceMap.keySet()) {
      FileTraceModel fileTraceModel = fileTraceMap.get(fullPath);

      String fileName = fullPath;
      String relativePath = "";
      int index = fullPath.lastIndexOf(File.separator);
      if (index > -1) {
        fileName = fullPath.substring(index + 1);
        relativePath = fullPath.substring(0, index) + "/";
      }

      repository = createTextFileInRepository(repository, relativePath, fileName,
          fileTraceModel.getContent());

      repository = createTextFileInRepository(repository, "traces/" + relativePath,
          fileName + ".traces", fileTraceModel.toJSONObject().toJSONString());
    }

    repository = createTextFileInRepository(repository, "traces/", "tracedFiles.json",
        traceModel.toJSONObject().toJSONString().replace("\\", ""));

    return repository;
  }

  /**
   * Commit multiple files to the github repository. Like
   * {@link i5.las2peer.services.codeGenerationService.CodeGenerationService#commitFile(String, JSONObject)}
   * , but without any trace information and for multiple files
   * 
   * @param repositoryName The name of the repository
   * @param commitMessage A commit message
   * @param files An array containing the file names and file contents
   * @param service An instance of {@link i5.las2peer.api.Service} needed to invoke the GitHubProxy
   *        service
   */


  private static void commitMultipleFilesRaw(String repositoryName, String commitMessage,
      String[][] files, Service service) {
    Serializable[] payload = {repositoryName, commitMessage, files};
    try {
      service.invokeServiceMethod("i5.las2peer.services.gitHubProxyService.GitHubProxyService@0.1",
          "storeAndCommitFilesRaw", payload);
    } catch (Exception e) {
      logger.printStackTrace(e);
    }
  }

  /**
   * Updates a given list of traced files in a local repository of the GitHub proxy service
   * 
   * @param fileList A list containing the files that should be updated
   * @param repositoryName The name of the repository
   * @param service An instance of {@link i5.las2peer.api.Service} needed to invoke the GitHubProxy
   *        service
   */

  protected static void updateTracedFilesInRepository(List<String[]> fileList,
      String repositoryName, Service service) {
    commitMultipleFilesRaw(repositoryName, "Code regeneration/Model synchronization",
        fileList.toArray(new String[][] {}), service);
  }

  /**
   * Creates a list of the traced files contained in a trace model
   * 
   * @param traceModel A trace model that contains the traced files
   * @param guidances The feedback rules used to perform the model violation detection.
   * @return A list of the traced files contained in the trace model
   * @throws UnsupportedEncodingException Thrown for errors during the encoding of the content of
   *         files
   */

  protected static List<String[]> getUpdatedTracedFilesForRepository(TraceModel traceModel,
      String guidances) throws UnsupportedEncodingException {
    Map<String, FileTraceModel> fileTraceMap = traceModel.getFilenameToFileTraceModelMap();

    List<String[]> fileList = new ArrayList<String[]>();

    for (String fullPath : fileTraceMap.keySet()) {
      FileTraceModel fileTraceModel = fileTraceMap.get(fullPath);

      String fileName = fullPath;
      String relativePath = "";
      int index = fullPath.lastIndexOf(File.separator);
      if (index > -1) {
        fileName = fullPath.substring(index + 1);
        relativePath = fullPath.substring(0, index) + "/";
      }

      String content = fileTraceModel.getContent();
      String fileTraceContent = fileTraceModel.toJSONObject().toJSONString();

      fileList.add(new String[] {"traces/" + relativePath + fileName + ".traces",
          Base64.getEncoder().encodeToString(fileTraceContent.getBytes("utf-8"))});
      fileList.add(new String[] {relativePath + fileName,
          Base64.getEncoder().encodeToString(content.getBytes("utf-8"))});

    }

    String tracedFiles = traceModel.toJSONObject().toJSONString().replace("\\", "");
    fileList.add(new String[] {"traces/tracedFiles.json",
        Base64.getEncoder().encodeToString(tracedFiles.getBytes("utf-8"))});

    fileList.add(new String[] {"traces/guidances.json",
        Base64.getEncoder().encodeToString(guidances.getBytes("utf-8"))});

    return fileList;

  }

  /**
   * Rename a file in the local repository hold by the GitHub proxy service
   * 
   * @param repositoryName The name of the repository
   * @param newFileName The new file name
   * @param oldFileName The old file name
   * @param service An instance of {@link i5.las2peer.api.Service} needed to invoke the GitHubProxy
   *        service
   */

  protected static void renameFileInRepository(String repositoryName, String newFileName,
      String oldFileName, Service service) {
    Serializable[] payload = {repositoryName, newFileName, oldFileName};
    try {
      service.invokeServiceMethod("i5.las2peer.services.gitHubProxyService.GitHubProxyService@0.1",
          "renameFile", payload);
    } catch (Exception e) {
      logger.printStackTrace(e);
    }
  }

  /**
   * Delete a file in the local repository hold by the GitHub proxy service
   * 
   * @param repositoryName The name of the repository
   * @param fileName The name of the file that must be deleted
   * @param service An instance of {@link i5.las2peer.api.Service} needed to invoke the GitHubProxy
   *        service
   */

  protected static void deleteFileInLocalRepository(String repositoryName, String fileName,
      Service service) {
    Serializable[] payload = {repositoryName, fileName};
    try {
      service.invokeServiceMethod("i5.las2peer.services.gitHubProxyService.GitHubProxyService@0.1",
          "deleteFile", payload);
    } catch (Exception e) {
      logger.printStackTrace(e);
    }
  }

}
